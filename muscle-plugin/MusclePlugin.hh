#ifndef _GAZEBO_MUSCLE_HH_
#define _GAZEBO_MUSCLE_HH_

#include "gazebo/common/Plugin.hh"
#include "gazebo/common/PID.hh"
#include "gazebo/util/system.hh"
#include <sstream>
#include <gazebo/gazebo.hh>
#include <gazebo/physics/physics.hh>
#include <ignition/math/Vector3.hh>
#include <gazebo/common/common.hh>
#include <boost/bind.hpp>
#include <math.h>
#include <map>
#include <stdio.h>
#include <algorithm> 
#include <boost/numeric/odeint.hpp>

#include "ros/ros.h"
#include "ros/callback_queue.h"
#include "ros/subscribe_options.h"
#include "std_msgs/Float32.h"
#include "thread"



namespace gazebo
{
  
	using namespace std;
	using namespace boost::numeric::odeint; 

  struct Motor
    {
      float current;
      float torqueConst;
      float resistance;
      float inductance;
      float voltage;
      float BEMFConst; // back electromagnetic force constant
      float inertiaMoment;
    };

    struct Gear
    {
      float inertiaMoment;
      float ratio;
      float efficiency; // gear efficciency
      float appEfficiency; // approximated efficiency 
    };

    struct Spindle
    {
      float angVel; // angular velocity of the spindle
      float radius;
      float desVel; // desired velocity
    };

    struct SEE
    {
	  float stiffness;
	  float length;
	  float lengthRest;
    };


    class ITendon
 	{
	    ////////////////////////////////////////
	    /// \brief Calculate the dot product between two vectors
	    /// \param[in] _v1 vector 1 coordinates
	    /// \param[in] _v2 vector 2 coordinates
	    /// \return Dot product
	    private: float DotProduct(const math::Vector3 &_v1, const math::Vector3 &_v2);

	    ////////////////////////////////////////
	    /// \brief Calculate the angle between two vectors
	    /// \param[in] _v1 vector 1 coordinates
	    /// \param[in] _v2 vector 2 coordinates
	    /// \return Angle between two vectors in radians
	    private: float Angle(const math::Vector3 &_v1, const math::Vector3 &_v2);

	    ////////////////////////////////////////
	    /// \brief Calculate torque for an electric motor model.
	    /// \param[in] _current Input electric current
	    /// \param[in] _torqueConstant Motor's torque constant
	    /// \param[in] _spindleRadius Radius of the spindle that coils up the tendon
	    /// \return Calculated force according to the model
	    public: float ElectricMotorModel(const float _current,  const float _torqueConstant, 
	                                const float _spindleRadius);

	    ////////////////////////////////////////
	    /// \brief Calculate elastic force of the series elastic element
	    /// \param[in] _length0 Resting length of the SEE
	    /// \param[in] _length Current length of the SEE 
	    /// \param[in] _stiffness Deafault values for stiffness of the SEE
	    /// \return Elastic force in N
	    public: float ElasticElementModel(const float _length0, const float _length, 
	                                float _stiffness,  const float _speed, 
	                                const float _spindleRadius, const double _time);

	    ////////////////////////////////////////
	    /// \brief Calculate forces generated by the motor and SEE
	    /// \param[in] _elasticForce
	    /// \param[in] _motorForce  
	    /// \param[in] _instertionP Position of the insertion point of the tendon 
	    /// \param[in] _fixationP Position of the fixation point of the tendon 
	    /// \param[in] _jointP Position of the corresponding joint 
	    /// \return Motor force in N
	    public: math::Vector3 CalculateForce(float _elasticForce, float _motorForce, 
	                              const math::Vector3 &_instertionP,
	                              const math::Vector3 &_fixationP);

    }; 


  class IActuator
  {
	  	// state vector for differential model
		public: typedef std::vector< double > state_type;
		// private: std::vector< double > x(2);
	    
	    // stepper for integration
	    public: boost::numeric::odeint::runge_kutta4< state_type > stepper;

	    ////////////////////////////////////////
	    /// \brief Approximates gear's velocity
	    /// according to the direction of the rotation of the gear, i.e. 
	    /// eta or 1/eta
	    /// \return Approximated value for gear efficiency
	    public: static float EfficiencyApproximation();
	    // private: void DiffModel(const state_type &x , state_type &dxdt , const double /* t */);


	    ////////////////////////////////////////
	    /// \brief Describes the differential model 
	    /// for the simulations of dynamics 
	    /// of a DC motor, a spindle, and a gear box
	    public: static void DiffModel( const state_type &x , state_type &dxdt , const double /* t */ );
  };


	class MusclePlugin : public ModelPlugin
	{
  
	    public: MusclePlugin();
	    public: ~MusclePlugin();

	    public: void Load(physics::ModelPtr _parent, sdf::ElementPtr _sdf);
	    public: void Init();

	    private: void OnUpdate();
	    private: float VelocityController();

	    /// \brief Handle an incoming message from ROS
		/// \param[in] _msg A float value that is used to set the velocity
		/// of the Velodyne.
		public: void OnRosMsg(const std_msgs::Float32ConstPtr &_msg);

		/// \brief ROS helper function that processes messages
		private: void QueueThread();

		/// \brief Set the velocity of the Velodyne
		/// \param[in] _vel New target velocity
		public: void SetVelocity(const double &_vel);

	    private: event::ConnectionPtr connection;
	    private: common::Time prevUpdateTime;
	    private: common::Time controllerPrevUpdateTime;
	    private: physics::ModelPtr model;
	    private: std::vector<physics::LinkPtr> links;

	    /// \brief Position PID controllers.
      	private:  common::PID posPID;//std::map<std::string, common::PID> posPids;

      	// private: float desiredVel; // desired velocity

	    /// \brief A node use for ROS transport
		private: ros::NodeHandle *rosNode;//unique_ptr<ros::NodeHandle> *rosNode;

		/// \brief A ROS subscriber
		private: ros::Subscriber rosSub;

		/// \brief A ROS callbackqueue that helps process messages
		private: ros::CallbackQueue rosQueue;

		/// \brief A thread the keeps running the rosQueue
		private: std::thread rosQueueThread;

  };
}

#endif